<!DOCTYPE html>
<html>
<head>
    <title>Polygonal Network Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f0f0f0;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }
        /* Add your content styles here */
    </style>
</head>
<body>
    <!-- Your content goes here -->
    
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse position
        let mouse = { x: 0, y: 0 };
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // Network parameters
        const settings = {
            nodeCount: 30,    // Number of nodes in each dimension
            baseDist: 120,    // Base distance between nodes
            maxOffset: 40,    // Maximum mouse influence distance
            lineWidth: 1.5,   // Connection line width
            fillColor: 'rgba(200, 220, 255, 0.15)',  // Polygon fill
            strokeColor: 'rgba(100, 150, 200, 0.2)'  // Connection stroke
        };

        // Generate initial node grid
        let nodes = [];
        function generateNodes() {
            nodes = [];
            const cols = Math.ceil(canvas.width / settings.baseDist) + 2;
            const rows = Math.ceil(canvas.height / settings.baseDist) + 2;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    nodes.push({
                        x: x * settings.baseDist,
                        y: y * settings.baseDist,
                        baseX: x * settings.baseDist,
                        baseY: y * settings.baseDist
                    });
                }
            }
        }
        generateNodes();
        window.addEventListener('resize', generateNodes);

        // Update node positions based on mouse
        function updateNodes() {
            nodes.forEach(node => {
                const dx = mouse.x - node.x;
                const dy = mouse.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Mouse influence
                if (distance < settings.maxOffset * 4) {
                    const force = settings.maxOffset * (1 - distance/(settings.maxOffset * 4));
                    const angle = Math.atan2(dy, dx);
                    
                    node.x = node.baseX + Math.cos(angle + Math.PI) * force;
                    node.y = node.baseY + Math.sin(angle + Math.PI) * force;
                } else {
                    // Return to base position
                    node.x += (node.baseX - node.x) * 0.1;
                    node.y += (node.baseY - node.y) * 0.1;
                }
            });
        }

        // Draw triangular network
        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            nodes.forEach((node, i) => {
                const neighbors = [
                    nodes[i + 1],
                    nodes[i + Math.ceil(canvas.width / settings.baseDist) + 2],
                    nodes[i - 1]
                ];
                
                neighbors.forEach(neighbor => {
                    if (neighbor) {
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(neighbor.x, neighbor.y);
                        ctx.strokeStyle = settings.strokeColor;
                        ctx.lineWidth = settings.lineWidth;
                        ctx.stroke();
                    }
                });
            });

            // Draw polygons
            nodes.forEach((node, i) => {
                const neighbors = [
                    nodes[i + 1],
                    nodes[i + Math.ceil(canvas.width / settings.baseDist) + 2],
                    nodes[i - 1]
                ].filter(n => n);
                
                if (neighbors.length >= 2) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    neighbors.forEach(neighbor => ctx.lineTo(neighbor.x, neighbor.y));
                    ctx.closePath();
                    
                    ctx.fillStyle = settings.fillColor;
                    ctx.fill();
                }
            });
        }

        // Animation loop
        function animate() {
            updateNodes();
            drawNetwork();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
